[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "cellula",
    "section": "",
    "text": "This is the companion website to the cellula package.\ncellula is a simple R-based pipeline for single cell RNA-seq processing with a number of methods for integration and identity assignment.\ncellula follows the practices outlined in the OSCA book [1], with some additional options for integration/batch effect correction methods, signature scoring, and downsampling.\nAs a one-stop solution, this package tends to make choices for the users, with the caveat that these choices follow either defaults or sensible implementations. However, this means that a certain degree of freedom is removed from the end user. This assumes that users who desire total control on the process (or granular specification of parameters) do not need cellula and would be more comfortable setting up their own analysis pipelines.\ncellula exists to automate and share routine analyses the way I usually do them, and offer “quick and dirty” access for exploratory data analysis.\ncellula is very much under active development, and any feedback and contribution are welcome through the Issues page.\nWhere did the name “papplain” come from? it’s an inside joke with some friends and ex colleagues.\nWhy did you change it to “cellula”? one day I’d like to share this tool and I need a name that is not too dumb."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "install.html",
    "href": "install.html",
    "title": "Installing cellula",
    "section": "",
    "text": "Use remotes, devtools or BiocManager to install:\n\nremotes::install_github(\"gdagstn/cellula\")\ndevtools::install_github(\"gdagstn/cellula\")\nBiocManager::install(\"gdagstn/cellula\")\n\ncellula is dependency-heavy, which is not something I’m proud of, but makes sense considering this is a wrapper to a series of different analytical approaches.\nThe package will require a number of BioConductor and GitHub dependencies. You can install them as follows:\n\nBiocManager::install(c(\"scran\", \"scuttle\", \"bluster\", \"scater\", \"batchelor\", \"DropletUtils\", \n                      \"AUCell\", \"harmony\", \"GSVA\", \"gdagstn/oveRlay\", \"UCell\", \n                      \"slingshot\", \"TSCAN\", \"cole-trapnell-lab/monocle3\"))"
  },
  {
    "objectID": "usage.html",
    "href": "usage.html",
    "title": "Usage",
    "section": "",
    "text": "The pipelines in cellula assume that you are working with the output of CellRanger (or something similar) and you imported it into a SingleCellExperiment object (hereafter SCE) using the TENxIO package. This is relevant for gene identifiers, since the rowData slot of the SCE will have a “Symbol” and a “ID” column.\nFor demo purposes we can use a publicly available dataset, Segerstolpe et al. 2016[2], which we retrieve using the scRNAseq package:\n\n# BiocManager::install(\"scRNAseq\") \nsce <- scRNAseq::SegerstolpePancreasData()\ncolnames(rowData(sce)) = c(\"Symbol\", \"ID\")\n\nAssuming that you have formed a SCE object containing the “individual” column that identifies different batches, you can run an integration pipeline as follows:\n\nsce <- cellula(sce, name = \"myproject\", batch = \"individual\", \n                integration_method = \"Harmony\",\n                verbose = TRUE, save_plots = TRUE)\n\nThe name argument defines the name of the folder that will be created to store files and plots. We set verbose = TRUE to print the progress of the pipeline. Setting save_plots = TRUE will create a few QC plots in the name/plots folder: total UMI, total genes detected, UMI x genes; optionally % MT, % Ribo and %MALAT1, total UMI x doublet class. Plots are separated according to whether the cells were discarded or not in the filtering step.\nThe cellula() function is a wrapper around a few modules or sub-pipelines that have different degrees of customization.\nThere are other independent functions that are not run through cellula() as they need some user input, e.g. findTrajectories() requires the user to specify the starting cluster (through makeGraphsAndClusters()), or the cluster labels to use.\nThe scheme is:\ncellula()\n    ├── Quality Control [QC]\n    |    ├── run emptyDrops (optional) [QC/EMPTY]\n    |    ├── score mito/ribo/malat1 subsets (optional)\n    |    ├── filter out (optional)\n    |    └── doublet finding (optional) [QC/DBL]\n    ├── Normalization and dimensionality reduction [NOR]\n    |    ├── pre-clustering\n    |    ├── computing pooled factors\n    |    ├── log-normalization (simple or multi-batch)\n    |    ├── HVG finding (simple or multi-batch)\n    |    ├── PCA\n    |    └── UMAP\n    ├── Integration [INT] (optional) - choose one method\n    |    ├── fastMNN [INT/MNN]\n    |    |    ├── integration\n    |    |    └── UMAP\n    |    ├── Seurat [INT/SEURAT]\n    |    |    ├── conversion to Seurat\n    |    |    ├── normalization and HVG finding\n    |    |    ├── find integration anchors\n    |    |    ├── integrate data\n    |    |    ├── scale data\n    |    |    ├── PCA\n    |    |    └── UMAP\n    |    ├── LIGER [INT/LIGER]\n    |    |    ├── conversion to LIGER\n    |    |    ├── normalization\n    |    |    ├── HVG finding\n    |    |    ├── scale data\n    |    |    ├── NMF\n    |    |    ├── quantile normalization\n    |    |    └── UMAP\n    |    ├── Harmony [INT/HARMONY]\n    |    |    ├── Harmony matrix (on PCA)\n    |    |    └── UMAP\n    |    └── Regression [INT/regression]\n    |         ├── regression on logcounts\n    |         ├── PCA\n    |         └── UMAP\n    └── Cell type annotation [ANNO] (optional) - choose one method\n              ├── Seurat AddModuleScore\n              ├── ssGSEA\n              ├── UCell\n              ├── AUCell\n              └── Jaitin\n              \n  makeGraphsAndClusters()\n    └── Multi-resolution clustering [CLU]\n          ├── sweep on Louvain/Leiden resolution or SNN neighbor numbers\n          ├── calculate modularity (optional)\n          └── calculate silhouette (optional)\n              \n  findTrajectories()            \n    └── Trajectory estimation [TRAJ]\n          ├── slingshot [TRAJ/slingshot]\n          |   ├── get lineages\n          |   ├── calculate principal curves\n          |   ├── embed in 2D (optional)\n          |   └── calculate per-lineage DE (optional)\n          └── monocle3 [TRAJ/monocle]\n              ├── convert to CellDataSet\n              ├── learn graph\n              └── embed in 2D (optional)\n                   ├── populate FR layout (if dr_embed = \"FR\")\n                   └── UMAP on FR layout (if dr_embed = \"FR\")\n             \nMost of the choices can be made around the integration method. cellula has implemented 5 methods: fastMNN[3],[4] and regressBatches from the batchelor package, Harmony[5], the CCA-based Seurat[6] method, and non-negative matrix factorization (NMF) from LIGER[7] through the rliger package.\nLIGER and Seurat integration methods require an intermediate step where package-specific objects are created and some pre-processing steps are repeated again according to the best practices published by the authors of those packages.\nEach step of the pipeline can be called independently on the object:\n\nsce <- doQC(sce, name = \"segerstolpe\", batch = \"individual\", save_plots = TRUE)\nsce <- doNormAndReduce(sce, name = \"segerstolpe\", batch = \"individual\")\nsce <- integrateSCE(sce, batch = \"individual\", method = \"Seurat\")\n\nDoublet identification is carried out through the scDblFinder package[8] using standard defaults."
  },
  {
    "objectID": "plotting.html",
    "href": "plotting.html",
    "title": "Plotting",
    "section": "",
    "text": "cellula implements a few simple plotting functions for exploratory data analysis.\n\nplot_UMAP() to plot a UMAP (or any other 2D dimensional reduction)\nplot_Coldata() to plot data from the colData slot as a boxplot, scatterplot or confusion matrix\nplot_dots() to plot a dot plot of gene expression\n\n\nplot_UMAP()\nYou can choose point color using the color_by argument, and facetting is supported via the group_by argument. Additionally you can choose a shape_by for symbols, and label_by to place labels on the plot. Note that shape, group, and labels need to be categorical (i.e. factor) variables, whereas color can be numeric. The color palette is automatically generated, but it can be set by the user through the color_palette argument.\n\nplot_UMAP(sce, umap_slot = \"UMAP_Harmony\", color_by = \"individual\", group_by = \"disease\")\n\n\n\nplot_UMAP(sce, umap_slot = \"UMAP_Harmony\", color_by = \"sum\")\n\n\n\n\nplot_Coldata()\nTakes as input x and y as column names from colData(sce), with an optional color_by and group_by argument for facetting.\nThis function returns different plots depending on the class of the 2 colData columns selected: - if y is a numeric and x is categorical (character or factor), it returns a combined violin-boxplot with one plot per level of x.\n\nplot_Coldata(sce, x = \"individual\", y = \"sum\") + scale_y_log10()\n\n\nAdditionally, if the color_by argument specifies another column, every x will be divided by levels of color_by. With the appropriate use of the x, color_by and group_by variables once an look at 3 different groupings of y at once.\n\nplot_Coldata(sce, x = \"individual\", y = \"sum\", color_by = \"disease\", group_by = \"cell type\") + scale_y_log10()\n\n\nif y and x are both categorical, it returns a heatmap of the confusion matrix where every value is the pairwise Jaccard index between sets for any given level pair (this is mostly useful to check for differences in clustering/annotations)\nif y and x are both numeric, it returns a scatterplot with an optional 2D kernel density contour plot overlaid.\n\n\nplot_Coldata(sce, x = \"sum\", y = \"detected\") + scale_x_log10()\n\n\n\n\nplot_dots()\nYou can also use the plot_dots() function to plot the popular dot-plot for marker genes.\nThis function takes in a SingleCellExperiment object, together with a vector of genes (matched to the rownames of the object), and a grouping variable specified by the group_by argument. Additionally, dots can be ordered by hierarchical clustering on either genes, groups, or both (set cluster_genes and/or cluster_groups to TRUE, which is the default). Colors can also be customized via the color_palette argument. Finally, the user can choose whether they want genes to be columns (format = \"wide\", the default) or rows (format = \"tall\").\n\nplot_dots(sce, genes = top5, group_by = \"SNN_0.5\")"
  },
  {
    "objectID": "parallelization.html",
    "href": "parallelization.html",
    "title": "Parallelization",
    "section": "",
    "text": "Since cellula is mostly based on R/Bioconductor packages, it offers the BiocParallel parallelization backend through its parallel_param argument. In some cases, e.g. the Seurat integration, another type of backend has to be set up separately outside of the function call.\nBiocParallel parallelization is implemented where possible, i.e. all the steps of the pipeline where it is sensible to use them (PCA, clustering, integration…).\n\nsce <- integrateSCE(sce, batch = \"individual\", method = \"fastMNN\", \n                    parallel_param = MulticoreParam(workers = 4))"
  },
  {
    "objectID": "clustering.html",
    "href": "clustering.html",
    "title": "Clustering",
    "section": "",
    "text": "cellula offers a wrapper around clustering functions. For now, only SNN-based Louvain[9] and Leiden[10] clustering are implemented. The makeGraphsAndClusters() function allows users to do parameter sweeps along either the number of neighbors or the resolution of the clustering.\nIn this example we sweep along the value of the resolution parameter for a Louvain clustering. For the SNN graph constructions, edges are weighted according to the jaccard index of their shared neighbors, mimicking the Seurat graph construction and clustering procedure:\nIf another integration method has been run on the same object (e.g. Seurat integration), then the clustering can be performed on that integrated space by specifying the space argument (in this case, reducedDim(sce, \"PCA_Seurat\")):\nThe default value for space is NULL and will use the \"PCA\" slot from the reducedDim() accessor."
  },
  {
    "objectID": "clustering.html#plotting-clustering-results",
    "href": "clustering.html#plotting-clustering-results",
    "title": "Clustering",
    "section": "Plotting clustering results",
    "text": "Plotting clustering results\nYou can visualize clustering results on the UMAP using the plot_UMAP() function, adding labels if desired:\n\nplot_UMAP(sce, umap_slot = \"UMAP_Harmony\", color_by = \"SNN_0.5\", label_by = \"SNN_0.5\")\n\n\nIf using the clustree package[11], the clustering tree can be visualized by using the same prefix defined in makeGraphsAndClusters():\n\nlibrary(clustree)\nclustree(sce, prefix = \"SNN_\")\n\n\nThe default arguments to the clustering wrapper include the generation of modularity and approximate silhouette scores for every clustering round. These will be stored in the metadata of the SCE, named according to the prefix, the resolution, and the \"modularity_\" and \"silhouette_\" prefixes. Silhouette and modularity can be visualized by using the dedicated functions:\n\nplotSilhouette(sce, \"SNN_0.5\")\n\nplotModularity(sce, \"SNN_0.5\")\n\n \nAs seen in the Plotting section, you can plot cluster markers using the presto package and the plot_dots() function:\n\n# Install {presto}\nremotes::install_github(\"immunogenomics/presto\")\n\n# Quick and dirty marker calculation\nmarkers = presto::wilcoxauc(sce, group_by = \"SNN_0.5\")\nmarkerlist = split(markers, markers$group)\n\nfor(i in seq_len(length(markerlist))) {\n  markerlist[[i]]$deltapct = markerlist[[i]]$pct_in - markerlist[[i]]$pct_out\n  markerlist[[i]] = markerlist[[i]][order(markerlist[[i]]$deltapct, decreasing = TRUE),]\n}\n\ntop5 = lapply(markerlist, function(x) x$feature[1:5])\nmarkergenes =  Reduce(union, top5)\n\nplot_dots(sce, genes = top5, group_by = \"SNN_0.5\")"
  },
  {
    "objectID": "clustering.html#metaclusters",
    "href": "clustering.html#metaclusters",
    "title": "Clustering",
    "section": "Metaclusters",
    "text": "Metaclusters\nAditionally, metaclusters can also be identified. A metacluster is a cluster of clusters obtained by different clustering methods. Clusters across methods are linked acording to how many cells they share, and these links become edges of a graph. Then, Louvain clustering is run on the graph and the communities that are identified are metaclusters. These metaclusters show the relationship between clustering methods. Moreover, they can be used to understand cluster stability along different parameters and/or integration methods. A cell can belong to different clusters according to the clustering method (i.e. to the resolution or to the space that was used). If a cell belongs to clusters that are consistently included in a metacluster, then that cell belongs to a “stable” cluster. If instead the cell belongs to clusters that have different metacluster assignments, then it’s in an “unstable” position, meaning it may be clustered differently according to integration methods and/or resolutions.\nThe metaClusters() function takes a clusters argument, which is a vector of column names from the colData of the SCE where clustering results are stored. In this example it is easy to isolate by using grep() and searching for the prefix “SNN_”.\n\nclusterlabels <- colnames(colData(sce))[grep(\"SNN_\", colnames(colData(sce)))]\nsce <- metaCluster(sce, clusters = clusterlabels)\n\n\nEvery cell will belong to a series of clusters, which in turn belong to a metacluster. For every cell, we count how many times they are assigned to a particular metacluster, and the maximum metacluster is assigned, together with a “metacluster score” (i.e. the frequency of assignment to the maximum metacluster) and whether this score is above or below a certain threshold (0.5 by default). These columns are saved in the colData slot of the SCE.\n\nplot_UMAP(sce, umap_slot = \"UMAP_Harmony\", color_by = \"metacluster_score\", label_by = \"SNN_0.5\")"
  },
  {
    "objectID": "identities.html",
    "href": "identities.html",
    "title": "Assigning identities",
    "section": "",
    "text": "cellula implements 5 methods for automated cell identity assignment, 4 of which are signature-based, and one reference-based. The methods are based on the Bioconductor AUCell package[12], the GSVA ssGSEA implementation[13], the Seurat AddModuleScore() function, the UCell method[14] and the Jaitin method[15].\nFor the first 4 methods (\"AUCell\", \"ssGSEA\", \"AddModuleScore\" and \"UCell\") the function requires user-defined genesets, i.e. a named list containing genes to be used for scoring every single cell. These can be obtained through other packages, e.g. msigdbr. For instance, if we wanted to take all the Muraro et al.[16]. signature genes, present in the C8 collection, we would do:\n\nlibrary(msigdbr)\n\ntype_genes = msigdbr(\"Homo sapiens\", category = \"C8\")\n\ngenesets = lapply(split(type_genes, type_genes$gs_name), function(x) x$gene_symbol)\n\nmuraro_genes = genesets[grep(\"MURARO\", names(genesets))]\n\nThen, we would use the assignIdentities() function from cellula to calculate signature scores:\n\nsce = assignIdentities(sce, \n                       genesets = muraro_genes, \n                       method = \"AUC\")\n\nOther signature-based methods are \"Seurat\", \"UCell\", and \"ssGSEA\".\nA reference-based method, \"Jaitin\", is available. This method uses a matrix of gene expression as a reference, and then calculates the posterior probability for each cell in the sce object that its transcriptome matches any of the reference ones. The reference with the highest probability is selected as the best label. Importantly, for the “Jaitin” method it is possible to choose the assay to be used. If the user supplies a matrix of log-normalized counts as a reference, the assay argument should point to a similarly normalized data, e.g. \"logcounts\".\nassignIdentities() will create a column named “labels_AUC” (or anything else the user determines using the name argument) in the colData(sce). Assignments can be plotted:\n\nplot_UMAP(sce, umap_slot = \"UMAP_Harmony\", color_by = \"labels_AUC\")\n\n\nYou can now see why it can be useful to plot a confusion matrix as a heatmap:\n\nplot_Coldata(sce, x = \"SNN_0.5\", y = \"labels_AUC\")\n\n\nYou can also use single signatures as an input, which will result in adding the score to the colData slot of the SCE directly, rather than an assignment:\n\nsce <- assignIdentities(sce, \n                        genesets = muraro_genes$BETA_CELL, \n                        method = \"AUC\", \n                        name = \"Beta_Cell_signature\")\n\nplot_UMAP(sce, umap_slot = \"UMAP_Harmony\", color_by = \"Beta_Cell_signature\")\n\n\nThe \"UCell\" method works well when you have small signatures (e.g. even 2/3 genes). It allows you to specify positive and negative labels, which is useful when you are sure the identity of a cell types depends on the lack of expression of certain markers (see hematopoietic lineages). To do so, you can add “+” or “-” to each gene."
  },
  {
    "objectID": "trajectories.html",
    "href": "trajectories.html",
    "title": "Trajectory inference",
    "section": "",
    "text": "At the time of writing cellula only implements a wrapper around the slingshot method[18] and the monocle3 method [19] for pseudotemporal trajectory inference, and the testPseudotime() method from TSCAN[20] for differential expression along a trajectory. More trajectory inference and differential expression methods will be implemented in the future.\nThe monocle3 method has been originally developed to work on 2D embeddings such as UMAP, but given the distortion introduced by these embeddings this function allows users to input any embedding (such as PCA). Moreover, the monocle3 method originally allows partitions to be specified. In the current implementation partitions have been disabled.\nThe findTrajectories() function takes a SingleCellExperiment object as input, and requires the user to specify the method (one of \"slingshot\" or \"monocle\"), the cluster label which will be used as an input to the MST creation in slingshot, or to identify the starting node in monocle3.\nOther important parameters are:\nThe output is the same object used in the input, with some additional fields.\nIn this example we download a dataset that captures early haematopoietic differentiation from Nestorowa et al. [21] and we do a quick processing and clustering.\nThen we take an arbitrary starting point (cluster 7) and calculate trajectories with both slingshot and monocle using the same space (PCA, first 20 components).\nNow we can visualize results on the UMAP since we specified a dr_embed parameter. Notice how slingshot will identify different pseudotimes (one per lineage) while monocle3 will identify a single pseudotime. Moreover, the plot_UMAP() function can include a trajectory argument which points to the name of the element in the metadata slot containing segments to draw trajectories.\nSince the 2D embedding of monocle3 PCA-derived trajectories may be hard to understand, given the distortions introduced by UMAP, cellula includes an additional 2D embedding method, dr_embed = \"FR\", inspired båy the PAGA embedding initialization technique [22].\nBriefly, once the principal graph has been calculated, it is laid out in 2D using the Fruchterman-Reingold algorithm. Then each cell is randomly plotted around their closest vertex in the graph, and reordered according to pseudotime value. This semi-random layout is used as an initialization for UMAP, which will optimize the point positions. The resulting layout is more visually pleasing and reflects more accurately the positions of cells with respect to the trajectory (although not necessarily to each other).\nThis FR-initialized UMAP is stored in a reducedDim slot named UMAP_FR.\nIt should be noted that this layout is, in a way, optimized for trajectories rather than global cell-cell similarity and as always should only be treated as a visualization tool."
  },
  {
    "objectID": "trajectories.html#metacells",
    "href": "trajectories.html#metacells",
    "title": "Trajectory inference",
    "section": "Metacells",
    "text": "Metacells\nIn order to speed up calculations and overcome sparsity, cells can be aggregated into metacells using k-means clustering with a high k.\nClustering is carried out in the reduced dimensional space of choice selected through the space argument, and it is carried out in each level of group separately.\nRather than selecting the number of clusters k, the function takes an average number of cells per cluster w which is used to determine k (default is w = 10 cells per cluster). Read counts are aggregated by gene across all cells within each cluster, resulting in metacells. These can be used as input to findTrajectories() or other operations such as clustering, downsampling, signature scoring, etc.\nIn this example we create metacells aggregating (on average) 10 cells, within each cluster from the “SNN_0.5” clustering results:\n\nsce_meta <- makeMetacells(sce, group = \"SNN_0.5\", space = \"PCA_Harmony\", w = 10)"
  },
  {
    "objectID": "downsampling.html",
    "href": "downsampling.html",
    "title": "Downsampling",
    "section": "",
    "text": "There are two ways to downsample data in cellula: downsampling reads and downsampling cells.\nThe first approach simulates reads randomly sampling counts from a distribution with a fixed total number, using a vector of probabilities equivalent to the per-gene proportion of reads within each cell.\nBriefly, let’s consider a cell C in which genes a, b, and c have been quantified with 50, 30, 20 counts each (totaling to 100 counts). This is equivalent to a bag of marbles in which the probability of randomly picking an a marble is 50/100 = 0.5, b marble is 0.3, and c marble is 0.2.\nIf we want to downsample C to a total of 40 counts (yielding the downsampled C’), we randomly pick 40 counts from a (0.5, 0.3, 0.2) vector of probabilities.\nThis is a sort of downsampling by simulation and is described in Scott Tyler’s work[17], reimplemented in cellula with a slightly faster optimization.\nThe downsampleCounts() uses a minimum count number that is user-defined (or the minimum total count number in the dataset as a default) and returns a SingleCellExperiment object with the same number of cells as the input, and a down-sampled count matrix where each cell has the same total number of counts.\nThe second approach randomly select cells from within groups such as clusters, batches, or a combination of the two.\nCells are randomly selected so that they represent a user-defined fraction of the within-group total, with some lower bound to ensure that small groups are represented: if a rare cluster label only contains 9 cells and we want to downsample a dataset to 10%, we can cap the minimum to 5 cells so that we ensure the rare label is still adequately represented.\nThe downsampleCells() function returns a SingleCellExperiment object with fewer cells than the input, as defined by the proportion and min parameters."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "[1] Amezquita et al. Nat Methods. 2020 Feb; 17(2): 137–145\n [2] Segerstolpe et al. Cell Metab. 2016 Oct 11; 24(4): 593–607.\n [3] Haghverdi et al. Nat Biotechnol. 2018 Jun;36(5): 421-427.\n [4] Lun ATL. https://marionilab.github.io/FurtherMNN2018/theory/description.html\n [5] Korsunsky et al. Nat Methods. 2019 Dec;16(12): 1289-1296.\n [6] Stuart et al. Cell. 2019 Jun 13;177(7): 1888-1902.e21.\n [7] Welch et al. Cell. 2019 Jun 13; 177(7): 1873–1887.e17.\n [8] Germain et al. F1000Res. 2021; 10: 979\n [9] Blondel et al. J. Stat. Mech. 2008; P10008\n [10] Traag et al. Sci Rep. 2019; 9:5233.\n [11] Zappia and Oshlack Gigascience. 2018 Jul; 7(7): giy083.\n [12] Aibar et al. Nat Methods. 2017 Nov; 14(11): 1083–1086.\n [13] Hänzelmann et al. BMC Bioinformatics. 2013 Jan 16;14: 7.\n [14] Andreatta and Carmona Comput Struct Biotechnol J. 2021 Jun 30;19: 3796-3798.\n [15] Jaitin et al. 2015 Science 343, 776-779\n [16] Muraro et al. Cell Syst. 2016 Oct 26;3(4):385-394.e3\n [17] Tyler et al. biorXiv 2021 11.15.468733\n [18] Street et al. BMC Genomics. 2018 Jun 19;19(1): 477.\n [19] Cao et al. Nature. 2019 Feb;566(7745):496-502\n [20] Ji and Ji https://www.bioconductor.org/packages/release/bioc/html/TSCAN.html\n [21] Nestorowa et al. Blood. 2016 Aug 25;128(8):e20-31\n [22] Wolf et al. Genome Biol. 2019 Mar 19;20(1):59"
  }
]